<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[redis常用键值对解析]]></title>
      <url>/redis/2021/05/28/redis-key-value/</url>
      <content type="text"><![CDATA[导读：Redis不是简单的键值（Key-Value）存储，它实际上是一个支持不同类型值的数据结构服务器。在传统键值存储中，一般将字符串键与字符串值相关联，而在Redis中，其值不仅限于简单的字符串，还可以容纳更复杂的数据结构。Redis的常用键值对Redis的键值对Redis不是简单的键值（Key-Value）存储，它实际上是一个支持不同类型值的数据结构服务器。在传统键值存储中，一般将字符串键与字符串值相关联，而在Redis中，该值不仅限于简单的字符串，还可以容纳更复杂的数据结构。Redis-KeyRedis的键（Key）是二进制安全的字符串，这意味着可以使用任何二进制序列作为key，从“ foo”之类的字符串到JPEG文件的内容，同时空字符串也是有效的key键。在Redis的底层中由SDS实现。设置键的注意点：  key使用的字节不宜过长：太长的key字节，在内存方面不仅是个负担，并且在数据集中查找key时可能需要进行一些代价高昂的密钥比较。  key也不宜设置太短：与“ user：1000：followers”对比，“ u1000flw”写为key毫无意义，前者往往更具可读性。且与键对象本身和值对象使用的空间相比，单单添加key消耗的空间更少。  key使用同一种设置类型：例如，“ object-type：id”是一个好主意，例如“ user：1000”。点或破折号通常用于多字字段，例如“ comment：1234：reply.to”或“ comment：1234：reply-to”中。  允许的最大key大小为512 MB。Redis-ValueRedis的值（Value）支持以下几种类型：  Binary-safe strings：二进制安全字符串。  Lists：根据插入顺序排序的字符串元素的集合。它们基本上是链表。  Sets：唯一，未排序的字符串元素的集合。  Sorted sets：类似于集合，但是每个字符串元素在存入时都将于一个浮点数值的分数相关联，元素总是按照它们的分数排序，因此与Sets不同，可以检索一系列元素  Hashes：键值组成的哈希映射，键值都是字符串。  Bit arrays (or simply bitmaps)：可以使用特殊命令像位数组一样处理字符串值：可以设置和清除单个位，计数所有设置为1的位，找到第一个设置或未设置的位，等等。  HyperLogLogs：这是一个概率数据结构，用于估计集合的基数。  Streams：提供抽象日志数据类型的类地图项的仅追加集合。redis值的内部实现结构如下：            type类型      encoding编码      ptr指向的数据结构                  REDIS_STRING      REDIS_ENCODING_INT      整数值的实现的字符串对象              REDIS_STRING      REDIS_ENCODING_EMBSTR      embstr编码的sds实现的字符串对象              REDIS_STRING      REDIS_ENCODING_RAW      sds字符串实现的字符串对象              REDIS_LIST      REDIS_ENCODING_ZIPLIST      压缩列表实现              REDIS_LIST      REDIS_ENCODING_LINKEDLIST      链表实现              REDIS_HASH      REDIS_ENCODING_ZIPLIST      压缩表实现              REDIS_HASH      REDIS_ENCODING_HT      字典实现              REDIS_SET      REDIS_ENCODING_INTSET      整数集合实现              REDIS_SET      REDIS_ENCODING_HT      字典实现              REDIS_ZSET      REDIS_ENCODING_ZIPLIST      压缩表实现              REDIS_ZSET      REDIS_ENCODING_SKIPLIST      跳跃表和字典实现      Redis值的常用数据类型字符串：StringRedis字符串类型是与Redis键关联的最简单的值类型。它也是Memcached中唯一的数据类型。值是二进制安全的字符串，意味着redis的string可以包含任何数据。比如jpg图片或者序列化的对象。值最大能存储512 MB的数据。列表：Listredis是由双向链表（Linked List）的方式实现，而非数组形式。它能从链表的头尾进行操作。它是根据插入的顺序进行排序的有序列表。列表的常用案例：记住用户发布到社交网络上的最新更新。频繁查看的日志。集合：Setset 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。可以理解为一堆值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。有序集合：Sorted SetRedis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序。Redis有序集合添加、删除和测试的时间复杂度均为O(1)(固定时间，无论里面包含的元素集合的数量)。列表的最大长度为2^32- 1元素(4294967295，超过40亿每个元素的集合)。Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。哈希表：Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。每个 hash 可以存储 2^32 -1 键值对（40多亿）。参考：Redis DocumentationRedis维基百科]]></content>
      <categories>
        
          <category> redis </category>
        
      </categories>
      <tags>
        
          <tag> redis </tag>
        
          <tag> key-value </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[redis基础知识和底层数据结构]]></title>
      <url>/redis/2021/05/28/redis-data-structure/</url>
      <content type="text"><![CDATA[导读：Redis（Remote Dictionary Server）是一个在内存中运行的数据结构的存储服务器（an in-memory data structure store）。Redis支持各种抽象数据结构，例如字符串，列表，映射，集合，排序集合，HyperLogLogs，位图，流和空间索引。Redis基础知识概念：Redis（Remote Dictionary Server）是一个在内存中运行的数据结构的存储服务器（an in-memory data structure store）。Redis支持各种抽象数据结构，例如字符串，列表，映射，集合，排序集合，HyperLogLogs，位图，流和空间索引。用途：常被用于分布式、键值对数据库、高速缓存、消息代理等应用。redis的优点  内存操作，高性能  单线程执行，天然支持并发Redis的底层数据结构简单动态字符串：SDS描述Redis由C语言编写。它将SDS（simple dynamic string）用作默认的字符串表示方式。而C字符串仅用作字符串字面量（string literal），即无须对字符串值进行修改的地方。Redis的字符串类型的键值都是由SDS实现的。此外，SDS还可以被用作缓冲区（buffer），例如AOF缓冲区、输入缓冲区等。定义SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里。该空字符的添加操作由SDS函数自动完成。这一操作的好处是，可以直接复用C语言的一些字符串操作。每个sds.h/sdshdr表示一个SDS值，SDS的定义如下：struct sdshdr {  int len; // 记录buf数组中已使用的字节数量，等于SDS所保存字符串的长度    int free; // 记录buf数组中未使用的字节数量    char buf[]; // 字节数组，用于保存字符串}特性前置知识点：内存的重新分配操作可能出现的问题  缓冲区溢出：增长字符串时，程序需要通过内存分配来来确定是否需要对底层数组的空间进行扩充，以便存放增长后的字符串的值。如果忘了这一步，那么保存字符串的数组就会发生越界行为，占用未分配给它的内存区域，从而导致其他数据被意外篡改，这就是缓冲区溢出。  内存泄漏：缩短字符串时，同样需要重新分配内存释放掉不需要的那部分空间。如果忘了这一步，那么剩下那一部分空间将会一直处于未使用状态且无法分配给其他程序来使用，这就是内存泄漏。  内存重分配设计辅助的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。1. 空间预分配描述：空间预分配操作用于优化SDS字符串的增长操作。实现：  当修改后的SDS长度小于1MB时，那么程序将分配和len相同大小的未使用空间。这时len的值和free的值相同。  SDS的长度大于等于1MB时，那么会分配1MB的未使用空间。作用：通过内存重分配和空间预分配的策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数，从而提高性能2. 惰性空间释放描述：用于优化SDS字符串缩短操作。实现：  缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。作用：SDS避免了缩短字符串时所需的内存重分配操作。并为将来可能出现的增长操作提供了优化；不过有可能造成内存空间的浪费。3. 二进制安全描述：SDS的API都是二进制安全的。所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。4. 兼容部分C字符串函数描述：SDS末尾保存的空字串，使得其可以重用一部分库定义的函数，从而避免了不必要的代码重复实现。与C字符串相比的区别  长度获取简单。SDS用len属性记录了SDS字符串的长度，因此只需常熟复杂度就可以获取到字符串长度，而C字符串并不记录长度，它需要遍历整个字符串才能得出字符串长度。  len属性解决了扩充时C字符串的缓冲区溢出（buffer overflow）问题；  free属性减少修改字符串时带来的内存重分配次数。链表描述  链表提供了高效的节点重排能力，以及顺序性的节点访问方式。  链表在redis中的应用非常广泛，列表键的底层实现之一就是链表（当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时）。  此外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis本身还是用链表保存多个客户端的状态信息。定义adlist.h/list表示一个链表，而每个链表节点使用一个adlist.h/listNode结构表示。typedef struct list {  listNode *head;  listNode *tail;  unsigned long len; // 节点数量} list;typedef struct listNode {  struct listNode *prev;  struct listNode *next;  // 任意类型的值  void *value;} listNod字典描述  字典，又称符号表、关联数组、映射（map），用于保存键值对的抽象数据结构。  C语言并没有内置字典。因此字典又Redis本身实现。  除了用来表示数据库外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是长字符串时，Redis就会使用字典作为哈希键的底层实现。定义dict.h/dict表示一个字典。typedef struct dict {  // 特定类型函数  dictType *type;  // 私有数据  void *privdata;   // 哈希表  dictht ht[2];   // rehash索引，没有进行rehash时，值为-1  int trehashidx;} dict;dict.h/dictht表示一个哈希表。typedef struct dictht {  // 哈希表，这里相当于Java中的 Object [] table;  dictEntry **table;  // 大小，指数组  unsigned long size;   // 哈希表大小掩码，总是用于计算索引值，总是等于size - 1  unsigned long sizemask;     // 哈希表已有节点的数量  unsigned long used; } dictht;而每个哈希节点使用dictEntry表示。typedef struct dictEntry{  void *key;  // 值 可以是一个对象指针，或uint64_t整数或int64_t整数  union {    void *val;    uint64_t u64;    int64_t s64;  } v;   // 指向下一个哈希节点，用于解决键冲突（链地址法）  struct dictEntry *next;} dictEntry哈希算法字典用作数据库底层实现，或哈希键的实现时，Redis使用的MurmurHash2算法来计算哈希值key：键ht[x]：没有rehash时为ht[0]，rehash时ht[1]计算哈希值：hash = dict-&gt;type-&gt;hashFunction(key);计算在数组中的下标：index = hash &amp; dict-&gt;ht[x].sizemask;哈希冲突Redis使用了链地址法解决，在产生冲突的下标地址的链表中，使用头插法插入哈希节点。渐进式的RehashRedis也有一个负载因子用于控制，哈希表的数组大小。当负载因子超过承受限制或远低于预期时，就会进行rehash的操作，进行扩展或缩小哈希表。负载因子（load factor）计算方式：load_factor = ht[0].used / ht[0].size扩展时：条件：一般情况下，负载因子大于等于1，就进行扩展；在执行BGSAVE或BGREERITEAOF命令时，负载因子大于等于5才开始扩展。方法：  分配ht[1]的空间，size为：大于等于ht[0].used * 2的第一个2^n数  收缩时：条件：负载因子小于0.1，就开始收缩跳跃表描述Redis使用其作为有序集合键的底层实现之一。当一个有序集合包含的元素数量比较多，又或者集合中的元素都是长字符串时，Redis就会使用跳跃表作为有序集合的底层实现。整数集合描述整数集合是Redis用于保存整数值的集合抽象数据结构，当一个集合只包含整数值元素，且元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。它可以保存int16_t、int32_t、int64_t的整数值，并且保证集合有序且不会出现重复。定义每个intset.h/intset结构表示一个整数集合typedef struct intset {  uint32_t encoding; // 编码 三种类型int16_t、int32_t、int64_t  uint32_t length; // 元素数量  int8_t contents []; // 保存元素的数组，其保存的正真类型取决于encoding}升级新元素超过当前类型的范围时，就要向上转型，redis称为升级（upgrade）。例如16-32，32-64。当然，整数集合不支持降级操作，一旦升级，编码就会一直保持升级后的状态，这一点跟Java一样。步骤：  根据升级类型，扩展底层数组的空间大小，并未新元素分配空间  把数组中现有的元素转换成升级后的类型，并从最后一个元素开始将之移动到新的位置上（例如：16位的整数转为32位时，数组为每一个元素的空间都分配了32位。从最后一个元素开始移动，可以确保一次移动完毕，且不会造成数据损坏）  将新元素添加到数组（由于新元素是向上转型，那么新元素只能是大于或小于当前数组的所有数的情况。比如一个32位的正整数或负整数）压缩列表描述压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。也是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且列表项要么是小整数值、要么是比较短的字符串，那么Redis就会使用压缩列表做列表键的底层实现；当一个哈希键只包含少量键值对，并且键值对的键和值要么是小整数值、要么是比较短的字符串，那么Redis就会使用压缩列表做列表键的底层实现。定义由于是连续的内存块，且经过特殊编码的，因此它跟之前的几种数据结构不同。整个压缩列表的结构如下：zlbyte | zltail | zllen | entry1~~~entryn | zlendzlbyet：列表占用的内存字节数zltail：记录列表尾节点离列表的起始地址有多少字节zllen：记录列表包含的节点数量entry：每一个列表节点，数量不定zlend：特殊值0xFF（十进制255），用于标记压缩列表的末端每一个实体entry包含的内容如下：previous_entry_lenth  |  encoding  |  contentprevious_entry_lenth：记录压缩列表前一个节点的长度encoding：记录节点content属性所保存数据的类型和长度content：保存节点值，可以是一个字节数组或者整数对象描述：Redis没有直接使用上述的数据机构来实现键值对数据库，而是基于这些数据结构创建一个对象系统。Redis创建一个键值对时，最少会建两个对象，键的对象和值的对象；键总是一个字符串对象，而值可以是对象系统的任一种。对象系统：  对象系统包含：字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种。  对象系统实现了基于引用计数技术的内存回收机制：当程序不再使用某个对象的时候（什么情况下才表示不再使用呢，即引用计数为0时），这个对象所占用的内存就会被自动释放。此外该技术实现了对象共享机制，通过让多个数据库键公用同一对象来节约内存。  对象带有访问时间记录信息，其用于计算数据库键的空转时长（未被调用），在服务器启用了maxmemory功能的情况下，空转时长较大的键可能会被服务器优先删除。定义：每个对象都由一个redisObject结构表示：typedef struct redisObject{  // 类型 REDIS_STRING REDIS_LIST REDIS_HASH REDIS_SET REDIS_ZSET  unsigned type:4;  unsigned encoding; // 编码 决定了该类型使用什么底层数据结构  void *ptr; // 指向底层实现数据结构的指针  int refcount; // 引用计数 用于内存回收机制、共享机制  unsigned lru:22; // 记录对象的最后一次被访问时间  // ...} robj;ptr指针所指向数据结构，它的类型由encoding属性决定。encoding记录了对象所使用的编码，即对象使用了什么数据结构作为底层实现。对象的常用命令：            object encoding      值的编码                  object refcount      对象的引用计数              object idletime      对象的空转时长，该命令不会修改对象的lru属性              type      对象类型              del      删除键以及值              rename      重命键              expire             对象系统各编码使用的数据结构：            type类型      encoding编码      ptr指向的数据结构                  REDIS_STRING      REDIS_ENCODING_INT      整数值的实现的字符串对象              REDIS_STRING      REDIS_ENCODING_EMBSTR      embstr编码的sds实现的字符串对象              REDIS_STRING      REDIS_ENCODING_RAW      sds字符串实现的字符串对象              REDIS_LIST      REDIS_ENCODING_ZIPLIST      压缩列表实现              REDIS_LIST      REDIS_ENCODING_LINKEDLIST      链表实现              REDIS_HASH      REDIS_ENCODING_ZIPLIST      压缩表实现              REDIS_HASH      REDIS_ENCODING_HT      字典实现              REDIS_SET      REDIS_ENCODING_INTSET      整数集合实现              REDIS_SET      REDIS_ENCODING_HT      字典实现              REDIS_ZSET      REDIS_ENCODING_ZIPLIST      压缩表实现              REDIS_ZSET      REDIS_ENCODING_SKIPLIST      跳跃表和字典实现      数据结构的转换：            类型      转换规则                  REDIS_STRING      为整数值且可以用long型表示使用int；当保存字符串，且长度小于等于39字节，使用embstr编码；否则使用SDS              REDIS_LIST      全是整数或短字符串且元素少使用压缩列表，否则使用链表              REDIS_HASH      全是整数或短字符串且元素少使用压缩列表，否则使用字典              REDIS_SET      全是整数且元素少使用整数列表，否则使用字典              REDIS_ZSET      全是整数或短字符串且元素少使用压缩列表，否则使用跳跃表和字典      字符串对象int embstr raw字符串对象是五种类型中，唯一一种会被其他四种对象嵌套的类型。embstr编码与raw编码异同：  两者都使用了redisObject机构和sdsstr结构表示字符串  但是raw编码会调用两次内存分配函数来分别创建两个结构，而embstr只需一次且分配了连续的内存空间。  意味着释放内存时，前者也需要释放两次，而后者只需要释放一次。  embstr是读取连续内存空间的数据，因此读取速度更快  embstr是只读的，而raw可读写。embstr是专门用于保存短字符串的一种优化编码方式。embstr无法修改的只读对象。若要对其进行修改，会将embstr先转为raw对象，再执行修改命令常用命令：            set                         get                     append      在值后添加              strlen      字符串长度      列表对象ziplist linkedlist编码转换：  字符串元素的长度小于64字节，元素数量小于512个时，使用ziplist  通过配置文件修改：list-max-ziplist-value、list-max-ziplist-entries常用命令：            lpush      头部添加                  lpop      头部删除              rpush      尾部添加              rpop      尾部删除              llen      长度              lindex      返回下标的元素              lset      更新节点的元素              lrange key s e      展示范围内的元素      哈希对象ziplist hashtable当使用ziplist保存哈希键值时，将键和值都作为一个entry，然后以键在前值在后的顺序插入压缩表编码转换：  所有键值对的键和值，都是用字符串，且长度小于64字节，键值对数量小于64个时，使用压缩表  通过配置文件修改：hash-max-ziplist-value、hash-max-ziplist-entries常用命令：            hset      添加键值对                  hget      获取键的值              hdel      删除键对应的键值对              hlen      长度              hgetall      获取所有键值对      集合对象intset hashtable使用hashtable时，字典的每个键都是一个字符串对象，值则全是NULL。编码转换：  集合对象保存的元素都是用整数值，且元素数量不超过512个时，使用intset  通过配置文件修改：set-max-intset-entries常用命令：            sadd      添加元素                  scard      集合元素的数量              sismember      指定元素是否存在              smembers      获取所有元素              spop      随机删除一个元素并返回，在返回给客户端值后才会正真删除      有序集合对象ziplist skiplist&amp;hashtable压缩表的表现形式：  使用压缩表时，元素按分值从小到大进行排序，分值小的靠近表头，分值大的靠近表尾。  压缩表中，每个元素用两个连续的entry表示，第一个保存元素，第二个保存元素的分值。跳跃表和哈希表的表现形式：skiplist编码的有序集合对象使用zset结构作为底层实现，其同时包含一个字典和一个跳跃表：typedef struct zset{  zskiplist *zsl; // 跳跃表  dict *dict; // 字典}zset;虽然zset同时使用字典和跳跃表保存有序集合，但这两种结构都通过指针来共享相同元素的成员和分值，因此不会造成浪费额外的内存。编码转换：  有序集合对象保存的元素长度都小于64字节，且元素数量小于128个时，使用ziplist  通过配置文件修改：zset-max-ziplist-value、zset-max-ziplist-entries常用命令：            zadd      添加元素                  zrem      删除元素中的指定成员              zcard      集合元素的数量              zcount      分值在给定范围内的元素数量              zrange      返回给定索引范围的所有元素              zrank      元素的排名（相当于index+1）              zscore      给定元素的分值      内存回收描述：C语言并不具备自动内存回收的功能，Redis构建了一个引用计数（reference counting）计数实现的内存回收机制。对于一个对象而言，它的生命周期为创建对象、操作对象、释放对象三个阶段。引用计数：程序通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。引用计数在对象系统中的属性为：refcountrefcount的状态变化：  创建新对象时，对象的refcount值初始化为1  对象被新程序使用时，refcount++  新程序使用结束时，refcount–  当对象的引用计数为0时，对象占用的内存会被释放对象共享描述：对象的共享也是通过上述的refcount实现的。哪些对象会被共享：  Redis只对包含整数值的字符串对象进行共享。  Redis初始化服务器时，创建0-9999的字符串对象，用以实现这些整数值的共享  Redis不共享包含字符串的对象，那有会增加判断的复杂度，从而影响内存性能共享的实现：  将数据库键的值指针指向一个现有的值对象；  将被共享的值对象的引用计数加一对象的空转时长描述：lru属性，记录对象最后一次被访问的时间。作用：当服务器打开了maxmemory选项时，且回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。参考：Redis DocumentationRedis维基百科[Redis设计与实现-黄健宏]]]></content>
      <categories>
        
          <category> redis </category>
        
      </categories>
      <tags>
        
          <tag> redis </tag>
        
          <tag> 数据结构 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[函数式编程]]></title>
      <url>/java/2021/05/22/Functional-Programming/</url>
      <content type="text"><![CDATA[导读：函数式编程，或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算为该语言最重要的基础。函数式编程：Functional programming函数式编程的一些基本概念函数式编程，又称函数程序设计、泛函编程，是一种编程范式。函数式编程的定义：简单来说：函数式编程就是将计算机的程序运算比作数学中的函数运算，函数运算的最终结果只能取决于输入值。当使用相同参数调用函数时，它将始终返回相同的结果。规范来说：函数式编程有时被视为纯函数式编程的同义词，是将所有函数视为确定性数学函数或纯函数的函数式编程的一个子集。当使用一些给定参数调用纯函数时，它将始终返回相同的结果，并且不受任何可变状态或其他副作用(side effect)的影响。程序的副作用：定义：如果一次操作、一个方法或一个表达式在其本地环境之外修改了一些变量的状态，那么就可以认为程序产生了副作用。副作用包括修改非局部变量、修改静态局部变量、修改通过引用传递的可变参数、执行I/O或调用其他副作用函数。副作用的表现：  在方法变更一个状态后将其从新变更为新的状态  在方法执行期间变更本地（非当前方法的局部变量）或全局的变量  方法执行未返回前的一次数据库保存操作  在方法中打印的日志  在方法中执行I/O操作函数编程与数学函数：数学中的函数：将函数输入和输出相关联的表达式，函数的输出值始终依赖于函数的输入值。此外，多个函数可以组合成一个新的函数形式。类似如下例子。表达式：y=x^2 - 1，输入：x=5，输出：y=24，且当x=5时，输出始终为24；那么函数式编程也是类似的，有表达式：函数体（代码块），输入：方法参数，输出：返回值。设计函数式编程应该遵循的原则：  First-Class and Higher-Order Functions  纯函数  不变性  引用透明当然以上原则并不需要完全遵循，只是作为更为完美的函数设计的参考。下面将对上述的原则一一解释⭐First-Class and Higher-Order FunctionsFirst-Class Function：一等函数，即在一门编程语言中，函数与变量并没有实质区别，函数也可以同普通变量一样，作为参数传递给其他函数，或将它们作为其他函数的值返回，并将它们分配给变量或将它们存储在数据结构中。这就意味着，函数名称与普通变量一样，其将被定义为函数类型 + 函数名称，如同 int a一样，只是这里的函数名称实际是由代码块组成的函数运算块。Higher-Order Function：高阶函数有两以下两个特征：  将一个或多个函数作为参数  将函数作为结果返回一等函数和高阶函数的区别：  一等函数针对编程语言：当某种语言具有一等函数特性时，那么该语言将会把函数视为普通变量。更常见的说法是“一种语言是否支持一等函数”。  高阶函数针对函数：高阶函数是对其他函数起作用的函数，当一个函数有N个函数作为参数或将函数作为返回值，那么该函数就是一个高阶函数。  这两件事密切相关，因为很难想象一种具有一流函数的语言不支持高阶函数，相反，很难想象具有高阶函数但没有一流函数支持的语言。⭐纯函数（Pure Functions）：即是没有副作用的函数。⭐不变性（Immutability）：即一个对象被实例化后，其属性不能够被改变。这是语言级别的设计支持的。在 Java 中，我们必须自己创建不可变的数据结构（正如String、基本类型、math类一样）。Immutables和Project Lombok提供了现成的框架，用于在 Java 中定义不可变数据结构。⭐引用透明（Referential Transparency）：如果将表达式替换为其相应的值，且没有对程序的行为造成影响时，那么该表达式就是引用透明的。换句话说，引用透明的表达式没有副作用且具有不变性。下面是baeldung的一个例子：public class SimpleData {  private Logger logger = Logger.getGlobal();  private String data;  public String getData() {    logger.log(Level.INFO, "Get data called for SimpleData");    return data;  }  public SimpleData setData(String data) {    logger.log(Level.INFO, "Set data called for SimpleData");    this.data = data;    return this;  }}// 对logger的三个调用在语义上是等效的，但在引用上并不透明String data = new SimpleData().setData("Baeldung").getData();// 不是引用透明的，因为它会产生副作用，其将会打印一条日志。如果我们像第三次调用一样用它的值替换这个调用，我们将不会打印该日志。logger.log(Level.INFO, new SimpleData().setData("Baeldung").getData());// 不是引用透明的，因为SimpleData是可变的。logger.log(Level.INFO, data);logger.log(Level.INFO, "Baeldung");函数式编程的作用：采用函数式编程的最大优势是纯函数和不可变状态。大多数编程的挑战的根源在于副作用和可变状态。去掉它们会使我们的程序更易于阅读、推理、测试和维护。函数式接口说明：函数式接口实际上只是函数式编程的定义，它将作为方法参数，被传给其他方法，而实现这些接口的方法一般被表现为lambda表达式（当然你也可以用一般接口的形式来实现函数式接口，也可以通过匿名内部类来实现，但lambda表达式实际上就是为了简化上述情况而产生的）。函数式接口的定义：要定义一个函数式接口，需要满足以下两种情况  使用@FunctionalInterface注解，标注接口为函数式接口  接口内部必须只有一个或以下的普通接口方法。但可以有任意数量的接口默认方法和接口静态方法，这些都不影响函数式接口的定义。JDK中的函数式接口：Function：接受一个参数，并返回一个结果@FunctionalInterfacepublic interface Function&lt;T, R&gt; {    // 接受一个参数，并返回一个结果    R apply(T t);    // apply方法的组合实现 表示before.apply(v)的函数输出值r将作为this.apply(r)的输入值    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {        Objects.requireNonNull(before);        return (V v) -&gt; apply(before.apply(v));    }    // apply方法的组合实现 表示this.apply(t)的函数输出值r将作为after.apply(r)的输入值    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; after.apply(apply(t));    }        // 函数将永远将输入参数作为输出参数    static &lt;T&gt; Function&lt;T, T&gt; identity() {        return t -&gt; t;    }Predicate：接受一个参数，返回Boolean@FunctionalInterfacepublic interface Predicate&lt;T&gt; {    // 接受一个参数，返回Boolean    boolean test(T t);    // 表示两个Predicate的与判断 this.test(t) and a.test(t)    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) &amp;&amp; other.test(t);    }        // 表示非Predicate的判断 !this.test(t)    default Predicate&lt;T&gt; negate() {        return (t) -&gt; !test(t);    }    // 表示两个Predicate的或判断 this.test(t) or a.test(t)    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {        Objects.requireNonNull(other);        return (t) -&gt; test(t) || other.test(t);    }    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {        return (null == targetRef)                ? Objects::isNull                : object -&gt; targetRef.equals(object);    Supplier：无参返回一个结果。该函数可以接受无参构造方法、无参方法来返回一个结果@FunctionalInterfacepublic interface Supplier&lt;T&gt; {    // 无参返回一个结果    T get();}Consumer：接受一个参数，并处理，无返回结果@FunctionalInterfacepublic interface Consumer&lt;T&gt; {    // 接受一个参数，并处理，无返回结果    void accept(T t);    // 组合操作 表示消费的先后顺序，当前实例消费完成后，after才开始消费    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {        Objects.requireNonNull(after);        return (T t) -&gt; { accept(t); after.accept(t); };    }实例：使用上面的函数接口实现简单的判断和输出功能：public class FITest&lt;T, R&gt; {    public static void main(String[] args) {        // 判断输入的密码是否正确 正确时计算并返回结果        FITest&lt;String, String&gt; fiTest = new FITest&lt;&gt;();        Scanner sc = new Scanner(System.in);        System.out.print("请输入密码： ");        String key = sc.next();        String result = fiTest.getIfTrue(key, // 输入数据                k1 -&gt; k1 + " Is Right KEY! ", // Predicate判断为真时的回调方法                k2 -&gt; k2.equals("KEY") // 判断条件        );        System.out.println(result);    }    // 判断正确时打印输出    public R getIfTrue(T t, Function&lt;T, R&gt; function, Predicate&lt;T&gt; predicate) {        if (!predicate.test(t)) {            System.err.println("密码错误！");            return null;        }        return function.apply(t);    }}// 输入输出结果请输入密码： NKEYnull密码错误！----------------------请输入密码： KEYKEY Is Right KEY! Lambda表达式：Lambda Expressions概念：即是一个匿名函数，即没有函数名的函数。Lambda表达式可以让我们不用实现函数式接口，而是通过函数体完成其接口方法。Lambda是实现回调函数（callback function）的一种方式。结构：（输入 +） 函数体 （+ 输出）// 输入(String a)   // "-&gt;" 符号后的部分都可以当作函数体 // 输出一个String类型的变量upper(String a) -&gt; {    String upper = a.toUpperCase();    System.out.println(upper);    return upper;}语法规则：  声明类型、不声明类型(int a, int b) -&gt; a + b(a, b) -&gt; a - b// 前面两个表达式含义相同，相当于下面的方法int sum(int a, int b) {  return a +b;注意：单个参数需要声明类型时，必须使用“()”圆括号。// 一个入参(List&lt;String&gt; l) -&gt; {  l.forEach(element -&gt; System.out.println(element));}  有输入参数、没有输入参数(String a) -&gt; new String(a)// 需要一个没有内容的括号表示无参() -&gt; new String()// 以上相当于一个是有参方法，一个是无参方法String newStr(String a) {  return new String(a);}String newStr() {  return new String();  单条执行语句、多条执行语句() -&gt; "lambda".toUpperCase()() -&gt; {    // other statement    return "lambda".toUpperCase();}注意：单条语句可以省去“{}”  带有输出的Lambda表达式、不带有输出// 有返回值(List&lt;String&gt; list) -&gt; {    return list;}(List&lt;String&gt; list) -&gt; list// 无返回值(List&lt;String&gt; list) -&gt; {    list.clear();}(List&lt;String&gt; list) -&gt; list.clear()注意：  当函数体只有一条且为输出语句时，需要确保简写表达式语句有返回值  当无返回值的表达式只有一条时，需要确保简写表达式不会有返回值方法引用：Method Reference定义：当使用一个Lambda表达式创建一个匿名函数时，如果该函数什么都不做，仅仅只是调用一个现有的方法时，就可以使用方法的名字来代表该方法的调用。方法引用即是用现有方法的名字，来紧凑的表达一个易于阅读的Lambda表达式。方法引用使用两个冒号 :: 表示方法引用种类：            种类      句法      例子                  引用静态方法      ContainingClass::staticMethodName      Person::compareByAgeMethodReferencesExamples::appendStrings              引用类的实例对象的方法      containingObject::instanceMethodName      myComparisonProvider::compareByNamemyApp::appendStrings2              引用特殊类型的任意对象的实例方法      ContainingType::methodName      String::compareToIgnoreCaseString::concat              引用构造函数      ClassName::new      HashSet::new      下面的代码是Oracle文档的一段代码实例：import java.util.function.BiFunction;public class MethodReferencesExamples {        public static &lt;T&gt; T mergeThings(T a, T b, BiFunction&lt;T, T, T&gt; merger) {        return merger.apply(a, b);    }        public static String appendStrings(String a, String b) {        return a + b;    }        public String appendStrings2(String a, String b) {        return a + b;    }    public static void main(String[] args) {                MethodReferencesExamples myApp = new MethodReferencesExamples();        // Calling the method mergeThings with a lambda expression        System.out.println(MethodReferencesExamples.            mergeThings("Hello ", "World!", (a, b) -&gt; a + b));                // Reference to a static method        System.out.println(MethodReferencesExamples.            mergeThings("Hello ", "World!", MethodReferencesExamples::appendStrings));        // Reference to an instance method of a particular object                System.out.println(MethodReferencesExamples.            mergeThings("Hello ", "World!", myApp::appendStrings2));                // Reference to an instance method of an arbitrary object of a        // particular type        System.out.println(MethodReferencesExamples.            mergeThings("Hello ", "World!", String::concat));   结语：花费了大概一周的空闲时间，终于对函数式编程有了初步的了解，接下来，将会继续学习函数式编程在Java中的实际应用：Stream流式操作。也希望能在实际的编码中能写出优美、可读性强且可维护性高的函数式编程语句，加油！当然，如果文中有错误，也希望能即时提醒。参考Lambda ExpressionsFunctional Programming in JavaFunctional programmingMethod ReferencesAny difference between First Class Function and High Order Functionfirst-class functions：函数是一等公民Higher-order_functionFirst-class_functionSide effect]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Lambda </tag>
        
          <tag> Stream </tag>
        
          <tag> functional programming </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[java反射机制]]></title>
      <url>/java/2021/05/21/JAVA-reflection/</url>
      <content type="text"><![CDATA[导读：反射通常由需要检查或修改java虚拟机中运行的应用程序的运行时行为的程序使用。反射是一种强大的技术，可以使应用程序执行原本不可能的操作。java反射机制反射原理：java在编译之后，会将Java代码生成为class源文件，JVM启动时，将会载入所有的源文件，并将类型信息存放到方法区中，将所有对象实例存放在Java堆中。  对于获取或创建新的类型实例：反射是在运行时，通过读取方法区中的字节码，来动态的找到其反射的类或类的方法和属性等（实际上就是在运行时，根据全类型名在方法区找对应的类），以实现类型的检查或创建该类的实例对象。  对于修改或获取存在的实例对象：一般来说，我们不通过反射构建的实例对象，通过编译器后都能预先的知道该实例对象有哪些属性和方法，从而可以直接获取或调用方法或属性。  而反射则不同，由于是运行时进行操作，它没法知道反射的这个实例对象有哪些属性和方法，因此需要先获取该对象的类型信息，从而通过该类型信息的属性或方法来修改实例对象。反射的用途：反射功能通常用于检查或修改java虚拟机运行中（runtime）的应用程序的行为。反射是一种强大的技术，可以运行原本不可能的操作。  在运行中分析类的能力，可以通过完全限定类名创建类的对象实例。  在运行中查看和操作对象，可以遍历类的成员变量。  反射允许代码执行非反射代码中非法的操作，可以检索和访问类的私有成员变量，包括私有属性、方法等。注意：要有选择的使用反射功能，如果可以直接执行操作，那么最好不要使用反射。反射的缺点：  额外的性能开销（Performance Overhead）：由于反射涉及动态类型的解析，它无法执行某些java虚拟机优化，因此反射操作的性能通常要比非反射操作慢。  安全限制（Security Restrictions）：反射需要运行时操作权限，此操作可能在一些安全管理器下不被允许。  内部泄露（Exposure of Internals）：由于反射允许代码执行非反射代码中非法的操作（例如访问私有字段和方法），因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射性代码破坏了抽象，因此可能会随着平台的升级而改变行为。获取对象类的方式:  Object.getClass()。从一个实例对象中获取它的类。这仅适用于继承自Object的引用类型（当然java的类默认继承于Object）。Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();Class&lt;? extends Map&gt; aClass = hashMap.getClass();String text = "text";Class&lt;? extends String&gt; aClass1 = text.getClass();// Object类public final native Class&lt;?&gt; getClass();  XXX.class。直接从未实例化的类获取类。Class&lt;Integer&gt; integerClass = int.class;Class&lt;HashMap&gt; hashMapClass = HashMap.class;  Class.forName()。通过完全限定类名获取类。即包名加类名（java.util.HashMap）。否则会报找不到类错误。Class&lt;HashMap&gt; hashMapClass = Class.forName("java.util.HashMap");// class类public static Class&lt;?&gt; forName(String className)            throws ClassNotFoundException {    Class&lt;?&gt; caller = Reflection.getCallerClass();    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);}  Integer.TYPE。基本类型的包装类通过TYPE获取类。都是java早期版本的产物，已过时。// Integer@SuppressWarnings("unchecked")public static final Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass("int");// Double@SuppressWarnings("unchecked")public static final Class&lt;Double&gt;   TYPE = (Class&lt;Double&gt;) Class.getPrimitiveClass("double");  通过反射类ClassAPI获取类。注意，只有在已经直接或间接获得一个类的情况下，才可以访问这些API。try {  Class&lt;?&gt; className = Class.forName("java.lang.String");  // 获取父类  Class&lt;?&gt; superclass = className.getSuperclass();  // 返回调用类的成员变量，包括所有公共的类、接口和枚举  Class&lt;?&gt;[] classes = className.getClasses();  // 返回调用类的依赖，包括所有类、接口和显式声明的枚举  Class&lt;?&gt;[] declaredClasses = className.getDeclaredClasses();} catch (ClassNotFoundException e) {  e.printStackTrace();}获取类的成员变量：获取字段：            Class API      是否是列表      是否获取父类属性      能否能获取私有字段                  getDeclaredField()      no      no      yes              getField()      no      yes      no              getDeclaredFields()      yes      no      yes              getFields()      yes      yes      no      获取方法：            Class API      List of members?      Inherited members?      Private members?                  getDeclaredMethod()      no      no      yes              getMethod()      no      yes      no              getDeclaredMethods()      yes      no      yes              getMethods()      yes      yes      no      获取构造器：            Class API      List of members?      Inherited members?      Private members?                  getDeclaredConstructor()      no      N/A1      yes              getConstructor()      no      N/A1      no              getDeclaredConstructors()      yes      N/A1      yes              getConstructors()      yes      N/A1      no      java.lang.reflect.FieldField字段具有类型和值。Field提供访问属性对象类型信息的方法；以及获取和设置字段值的方法。获取字段类型：字段可以是原始类型或引用类型。有八种基本类型：boolean，byte，short，int，long，char，float，和double。引用类型是java.lang.Object类的直接或间接子类，包含接口，数组和枚举类型等 。获取字段修饰符：  访问修饰符：public，protected，和private  仅用于字段的控制运行时行为的修饰符：transient和volatile  限制单实例的修饰符： static  禁止值修改的修饰符： final  注解Class&lt;?&gt; className = Class.forName("java.util.HashMap");Field table = className.getDeclaredField("table");// 获取属性的名字String name = table.getName();// 获取属性的类型Class&lt;?&gt; type = table.getType();// 获取修饰符int modifiers = table.getModifiers();System.out.println(Modifier.toString(modifiers));// 获取注解Override annotation = table.getDeclaredAnnotation(Override.class);Annotation[] declaredAnnotations = table.getDeclaredAnnotations();获取和设置字段值：给定一个类的实例，可以使用反射来设置该类中字段的值。通常仅在特殊情况下无法以常规方式设置值时才执行此操作。因为这样的访问通常会违反该类的设计意图，所以应绝对谨慎地使用它。注意：通过反射设置字段的值会有一定的性能开销，因为必须进行各种操作，例如验证访问权限。从运行时的角度来看，效果是相同的，并且操作是原子的，就好像直接在类代码中更改了值一样。除此之外，反射会破坏java原本的设定，列如可以重新设置final属性的值等。反射修改final修饰的属性值到JVM对String的优化：反射功能强大，能修改private以及final修饰的变量。如下代码中，展示了JVM的优化以及反射的一些劣势。@Datapublic class FieldReflectDemo {  // 引用直接指向常量池中的常量值  private final String constantStr = "FinalConstantStringField";  // JVM优化了getter方法，直接将对constantStr引用全部替换成了常量//  public String getConstantStr() {return "FinalConstantStringField";}  // 在堆中新建了一个对象  private final String newStr = new String("FinalNewStringField");    public FieldReflectDemo(){}        public static void main(String[] args) {    FieldReflectDemo fieldReflectDemo = new FieldReflectDemo();    try {      Class&lt;?&gt; className = fieldReflectDemo.getClass();      Field constantStr = className.getDeclaredField("constantStr");      Field newStr = className.getDeclaredField("newStr");      // 获取实例对象的字段值      System.out.println("constantStr原：" + constantStr.get(fieldReflectDemo));      System.out.println("newStr原：" + newStr.get(fieldReflectDemo));      constantStr.setAccessible(true);      newStr.setAccessible(true);      constantStr.set(fieldReflectDemo, "New Filed Name");      newStr.set(fieldReflectDemo, "New Filed Name");      System.out.println("constantStr反射修改：" + constantStr.get(fieldReflectDemo));      System.out.println("newStr反射修改：" + newStr.get(fieldReflectDemo));    } catch (NoSuchFieldException | IllegalAccessException e) {      e.printStackTrace();    }    System.out.println("constantStr实例对象值：" + fieldReflectDemo.getConstantStr());    System.out.println("newStr实例对象值：" + fieldReflectDemo.getNewStr());  }    /**   * 输出   * constantStr原：FinalConstantStringField   * newStr原：FinalNewStringField   * constantStr反射修改：New Filed Name   * newStr反射修改：New Filed Name   * constantStr实例对象值：FinalConstantStringField   * newStr实例对象值：New Filed Name   */}因为JVM在编译时期, 就把final类型的直接赋值的String进行了优化, 在编译时期就会把String处理成常量。反射成功将其值修改成功了，但是在它的get方法中，返回的不是当前变量，而是返回JVM优化好的一个常量值。java.lang.reflect.MethodMethod方法具有参数和返回值，并且方法可能抛出异常。Method提供获取参数信息、返回值的方法；它也可以调用（invoke）给定对象的方法。获取方法类型的信息：方法声明包含了方法名、修饰符、参数、返回类型以及抛出的多个异常。public class MethodReflectDemo {public MethodReflectDemo() {  private void getNothing(String name) {  public int getNumByName(String name) throws NullPointerException {  if (StringUtils.isEmpty(name))    throw new NullPointerException("名字为空");  return name.length();}  public static void main(String[] args) {    MethodReflectDemo methodReflectDemo = new MethodReflectDemo();    try {      Class&lt;? extends MethodReflectDemo&gt; demoClass = methodReflectDemo.getClass();      Method method = demoClass.getDeclaredMethod("getNumByName", String.class);      String name = method.getName();      System.out.println("方法名：" + name);      // 修饰符      int modifiers = method.getModifiers();      System.out.println("所有修饰符：" + Modifier.toString(modifiers));      // 参数      Parameter[] parameters = method.getParameters();      // 返回类型      Class&lt;?&gt; returnType = method.getReturnType();      System.out.println("返回类型：" + returnType.getTypeName());      // 异常      Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();      System.out.println("");      // 实例对象调用方法      Object invoke = method.invoke(methodReflectDemo, "名称");      System.out.println(invoke);    } catch (NoSuchMethodException e) {      e.printStackTrace();    }  }java.lang.reflect.ConstructorConstructor与Method相似，但有几点不同：  构造函数没有返回值  构造函数无法被实例对象执行，它的调用只能为给定的类创建对象的新实例。public class ConstructorReflectDemo {  public ConstructorReflectDemo() {}  private void getNothing(String name) { }  public int getNumByName(String name) throws NullPointerException {    if (StringUtils.isEmpty(name))      throw new NullPointerException("名字为空");    return name.length();  }  public static void main(String[] args) {    ConstructorReflectDemo methodReflectDemo = new ConstructorReflectDemo();    try {      Class&lt;? extends ConstructorReflectDemo&gt; demoClass = methodReflectDemo.getClass();      Constructor&lt;? extends ConstructorReflectDemo&gt; constructor = demoClass.getConstructor();      String name = constructor.getName();      System.out.println("构造方法名：" + name);      // 修饰符      int modifiers = constructor.getModifiers();      System.out.println("所有修饰符：" + Modifier.toString(modifiers));      // 参数      Parameter[] parameters = constructor.getParameters();      // 异常      Class&lt;?&gt;[] exceptionTypes = constructor.getExceptionTypes();      System.out.println("");      // 构造方法无法被调用，只可以创建新实例      ConstructorReflectDemo constructorReflectDemo = constructor.newInstance();    } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {      e.printStackTrace();    }  }}参考：The Reflection API]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> 反射 </tag>
        
          <tag> Reflection </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
