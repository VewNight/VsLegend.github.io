# 索引策略

## 独立的列
**描述**：索引列不能是表达式的一部分，也不能是函数的参数

**实例**：为index_id列建立索引，如下反例将不会使用到索引：
```sql
--表达式的一部分:
select * from user where id + 1 = 5;
--函数的参数：
select * from user where concat(code, '_3852') = 'xxxx_3852';
```
<br><br>

---

## 模拟哈希索引
**描述**：对于长字符串的列，索引时可以模拟哈希索引，即增加一个列用于保存这个长字符串的hash值。可以使用的哈希函数有CRC32、SHA1、MD5（CRC32返回的是32位的整数，如果数表非常大，它就会出现大量冲突；而后两者是强加密函数，设计目标是最大限度的消除冲突，但是后两者生成的是很长的字符串，会浪费大量空间，且比较时也会很慢）。

**优点**：

- 提高了对长字符串的索引性能

- 提高了指定查询的效率，访问哈希索引的数据非常快

**缺点**：

- 哈希索引不是按索引值顺序存储的，只支持等值比较查询，不支持任何范围查询，也无法用于排序

- 不支持部分索引列匹配查找

- 需要维护hash值

- 当hash冲突过多，一些索引的维护操作的代价会很高。比如，当删除一个hash冲突高的一个哈希索引时，存储引擎此时需要遍历多个hash值相等的行，以删除对应的数据，冲突越多，代价越大。


<br><br>

---

## 前缀索引和索引选择性
**描述**：除了使用模拟哈希索引外，对于长字符串，还可以使用前缀索引的方式。即只索引列开始部分的字符。要选择足够长的前缀以保证较高的选择性，使前缀索引的选择性接近于索引的整个列，同时又不能太长以便节约空间。

**优点**：这样可以大大节约索引空间，提高索引效率。

**缺点**：会降低索引的选择性（选择的前缀索引还是会存在冲突，即相等的情况）

>
>索引的选择性：是指不重复的索引值（基数cardinality）和数据表的记录总数的比值。选择性的值越大则重复性越低、查询效率越高。
>
>索引选择性的一般计算：
>
>
>```sql
SELECT COUNT(DISTINCT `name`) /COUNT(*) FROM `user`
SELECT COUNT(DISTINCT LEFT(`name`, 1)) /COUNT(*) FROM `user````


<br><br>

---

## 多列索引
**描述**：关于多列索引的常见错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多个索引。
实际上在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0以后的版本引入了索引合并的策略，一定程序上可以使表的多个单列索引来定位指定的行。

**索引合并（index merge）**：能使单列索引进行扫描，并将结果进行合并。这个算法有三个变种，OR条件的联合，AND条件的相交，组合前两种情况的联合及相交。


<br><br>

---

## 选择合适的索引列顺序
**描述**：正确的索引顺序依赖于使用该索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要。

**方法**：

- 当排序和分组不那么重要时，可以将选择性最高的列放刀索引最前列，这种索引方式能很大条件的优化WHERE条件的查询。

- 查询性能除了考虑选择性之外，还与考虑查询条件的具体值，也就是值的分布有关。这个时候应该根据那些查询频率最高的查询来调整索引列的顺序。


<br><br>

---

## 覆盖索引
**描述**：索引覆盖的意思是，索引的叶子节点（最底层节点）中已经包含了要查询的字段值，这样MySQL就可以通过索引来直接获取列的数据，这样就不再需要读取数据行了（在EXPLAIN的Extra列看到Using index时，就代表了使用了索引覆盖查询）。
实际上在5.6版本中，在存储引擎API上做了一个重要改进，即索引条件推送（index condition pushdown）。

**优点**：

- 索引条目远小于数据行时，如果要读取的数据索引中存在时，那MySQL就会极大的减少数据访问量。

- 索引的顺序存储形式，对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少得多。

- 覆盖索引对InnoDB特别有用，InnoDB的二级索引在叶子节点保存了行的主键值，如果二级主键能够覆盖查询，那么就可以避免对主键索引的二次查询。

**缺点**：

- 覆盖索引不易实现，大部分的关联查询中实现条件较为苛刻。假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段，5.5及之前的版本总是会回表获取数据行。

**实例**：

如果以下查询有一个多列索引（user_id, role_id），那么下面的查询就是一个覆盖查询，因为索引已经包含了查询结果。
```sql
SELECT user_id, role_id FROM user_role_relation
```

>如果查询也返回了主键，那么在innoDB中也是覆盖索引，因为任何一个二级索引，其叶子节点都保存了主键值。



<br><br>

---

## 避免索引无效的情况
**索引无效的情况**：查询表中的所有列无法名中任何索引，因为没有任何索引覆盖了所有列。

MySQL不能在索引中执行LIKE操作。MySQL能在索引中做最左前缀匹配的LIKE比较，，即LIKE 'word%'，是因为该操作可以转换为简单的比较操作（MySQL5.5及之前只允许索引做简单的比较操作、大于、小于、不等于）。


<br><br>

---

## 索引扫描排序
**概览**：MySQL生成有序结果的两种方式：通过排序算法进行的排序操作（extra Using filesort）；按索引顺序扫描（type index）。

> 如果EXPLAIN出来的type列的值为index，就说明MySQL使用了索引扫描来做排序;Extra显示Using filesort时，则是文件排序操作。

**描述**：扫描索引本身是很快的，因为它索引本身就是按顺序存储的树结构。但是如果索引不能覆盖查询所需的所有列，
那么就不得不扫描一条索引记录就都回表查询一次对应的行以获取其他所需的列（回表查询基本上都是随机IO，其磁盘地址很大程度上都不是连续分布的，这个时候按索引顺序读取数据的速度通常要比全表扫描慢）。

**实现要求**：

- 索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样，索引扫描排序以此为基础。

- 在关联多张表时，ORDER BY引用的字段必须全是第一个表的字段，且满足索引的最左前缀的要求。

- 当索引的前导列为常量时，可以不满足索引的最左前缀要求。例如WHERE或JOIN子句中指定了第一索引列为常量。


<br><br>

---

## 压缩（前缀压缩）索引

**描述**：MyISAM使用前缀索引来减少索引的大小，默认只压缩字符串。通过参数也可以对整数做压缩。

**压缩方法**：

1. 先保存索引块中的第一个值

1. 将其他值与第一个值进行比较，得到相同前缀的字节数

1. 保存剩余的不同后缀部分。

1. 将字节数和剩余的部分存储即可。

> 例如，索引块中只有perform、performance两个值，那么索引中保存的值为：(7,)、(7,ance)

**优点**：
- 压缩块使用了更少的空间，大概是非压缩索引的十分之一大小的磁盘空间。

- 对与I/O密集型应用（对CPU的利用率不高，大部分时间都用于等待IO的应用），某些查询带来的好处会比成本多很多。

**缺点：**

- 由于需要计算每个索引的剩余部分，因此某些操作可能更慢。

- 每个值的压缩前缀都依赖于前面的值，所以MyISAM查找时无法在索引块使用二分查找，只能从头扫描。

- 对于CPU密集型应用（CPU使用率高，大部分都在进行CPU进行计算的应用），因为扫描需要随机查找，使得查找要慢上好几倍。


<br><br>

---

## 避免冗余和重复索引
**描述**：
MySQL需要单独维护每一个索引，即使是索引重复索引，也需要单独维护。并且优化器在优化查询时，也需要逐个考虑这些索引，这势必会影响性能。

**重复索引**：

1. 指在**同列**上按**相同顺序**创建的**相同类型**的索引。

> 如果索引类型不同，并不算是重复索引。

2. 为主键创建普通索引、唯一性索引都是重复索引，因为唯一限制和主键限制就是通过索引实现的。

**冗余索引**：

1. 一个索引是另一个索引的前缀索引；二级索引中加上主键。

1. 大部分情况下都不需要冗余索引，而是扩展现有索引。

1. 当考虑性能方面时，扩展现有索引有可能导致已有索引变得太大。从而影响其他使用该索引的查询性能，这个时候可以考虑使用冗余索引。

> 不同类型的索引（哈希索引或全文索引），都不会是B-Tree索引的冗余索引。

**未使用的索引**：
一些永远使用不到的索引，建议考虑删除。


<br><br>

---

## 使用强制索引
当MySQL优化器所选择的索引并不是最合适的时候，自己可以主动调整强制使用的索引，语法如下：

```sql
SELECT * FROM table FORCE INDEX(索引名) WHERE statement
```


<br><br>

---
