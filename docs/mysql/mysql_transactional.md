# 数据库事务

## 事务ACID

- 原子性atomicity：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
事务不可分割、不可约简。

- 一致性consistency：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。

- 隔离性isolation：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。

- 持久性durability：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

<br><br>

---

## 四个隔离级别
1. 未提交读READ UNCOMMITTED
> 
>事务中的修改，即使未提交，对其他事务也是可见的。
> 
>问题：胀读、不可重复读、幻读
		
2. 提交读READ COMMITTED
> 
> 大多数数据库系统默认的隔离级别都是这一级别（MySQL不是）。一个事务在提交之前，所做的任务修改对其他事务都是不可见的。这一级别可称为不可重复读。
> 
> 问题：不可重复读、幻读
		
3. 可重复读REPEATABLE READ
> 
> 可重复读是MySQL的默认事务隔离级别。在同一事务中，多次读取同样记录的结果是一致的。
> 
> 问题：幻读
		
4. 可串行化SERIALIZABLE
> 
> 是最高的隔离级别。通过强制事务串行执行，改级别会在读取的每一行数据上加锁，所以可能导致大量的超时和锁的竞争问题。
> 
> 问题：锁竞争产生大量的超时问题

<br>

#### 隔离级别中的问题

- 胀读dirty read（误读）：事务可以读取未提交的数据。一个事务修改了一行数据但没有提交，第二个事务可以读取到这行被修改的数据，如果第一个事务回滚，第二个事务获取到的数据将是无效的。

- 不可重复读nonrepeatable read：两次执行同样的查询，得到的结果不一样。一个事务读取了一行数据，第二个事务修改了这行数据，第一个事务重新读取这行数据，将获得到不同的值。

- 幻读phantom read：当某个事务在读取某一范围内的记录时，另一事务又在改范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（phantom row）。一个事务按照一个where条件读取所有符合的数据行，第二个事务插入了一行数据且恰好也满足这个where条件，第一个事务再以这个where条件重新读取，将会获取额外多出来的这一行。
			
