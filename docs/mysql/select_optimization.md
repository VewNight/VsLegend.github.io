# 查询性能优化

> 注意：查询优化、索引优化、库表结构优化需要齐头并进。

## 访问数据优化
**问题**：

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃（查100条数据，Java实际只取了前10条的情况）。这会给MySQL服务器带来额外负担，同时增加了网络开销；也会消耗应用服务器的CPU和内存资源。

<br>

**分析步骤**：

1. 检查是否检索了大量超过需要的数据，这可能是访问了过多行或太多列。

1. 确定MySQL服务层是否分析大量超过需要的数据行。

<br>

**实际场景**：

1. 查询不需要的数据。如MySQL返回了100条，而Java只取了10条数据。
```sql
SELECT id, `name`
FROM user
```
> 优化：仅返回需要的行数。用LIMIT限制。

2. 多表关联时返回全部列或单表总是取出全部列。如下将返回所有关联表的列。
```sql
SELECT *
FROM `user` u
LEFT JOIN user_detail ud ON u.id = ud.user_id
```
> 
>分析：取出全部列会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的IO、内存和CPU消耗。
>不过这种浪费数据库资源的方式可以简化开发，因为它能提高相同代码的复用性。
>  
>优化：根据性能影响考虑，或者只选择需要的列。

3. 重复查询相同的数据

    对于常用且经常被查询的数据，可以通过一些缓存服务器将结果保存起来，避免不断重复执行相同的查询，且得到的是相同结果
> 如字典等数据就可以保存再redis中


<br><br>

---

## 减少扫描额外的记录

**一个简单的衡量指标**：

- 响应时间：实际上是指服务时间和排队时间。服务时间指数据库处理查询花费的时间；排队时间指服务器因等待某些资源而没有真正执行查询的时间，诸如等待IO操作、等待锁等等。

- 扫描的行数：查看查询扫描的行数能在一定程序上说明查询找到需要数据的效率。

- 返回的行数

<br>

**实际场景**：

1. 大量扫描但返回少的查询
    
    - 使用覆盖索引，将所有需要的列都放在索引中。
    
    - 改变库表结构，如使用单独的汇总表。
    
    - 重构查询，利用MySQL优化器优化查询方式。



<br><br>

---

## 将复杂查询分解
**问题**：

- 将查询设计为一个复杂还是多个简单查询的问题（单个简单的查询在多数时候都可以利用MySQL缓存和mybatis本地缓存）。

- 一方面，单次查询的优势在于：节省网络通信、查询解析和优化的成本（但实际上MySQL的连接都很轻量级，因此返回一个小的查询是很高效的）。

- 同时，MySQL内部每秒扫描内存中数据的效率很高，而MySQL响应数据给客户端就慢得多。其他条件相同的情况下，使用尽可能少的查询是更好的。

- 另一方面，如果一个查询过大，那么分为多个查询的好处就在于，可以将一次性压力分散，大大降低对服务器的影响，在编辑操作时还可以大大减少修改或删除锁的等待时间。

<br>

**实际场景**：

1. 切分查询

    定期删除大量数据，如果一次用一个大的语句一次性完成，那么可能锁住很多数据、占满事务日志、耗尽系统资源、阻塞很多小但重要的查询等。这时可以考虑切分成很多较小的删除语句。
比如每次只删除一小部分，然后写个循环操作，直至删除完成。


2. 分解关联查询。

```sql
SELECT id, `name`, phone, id_card
FROM `user` u
LEFT JOIN user_detail ud ON u.id = ud.user_id
-- 分解为
SELECT id
FROM `user`
SELECT user_id id, `name`, phone, id_card
FROM user_detail
WHERE user_id = 'id'
```
>好处：
>
>- 让缓存更高效
>
>- 将查询分解后，执行单个简单查询可以减少锁的竞争
>
>- 在应用层关联，可以更容易对数据库做拆分，更容易做到高性能和高扩展。
>
>- 查询本身效率有可能提升（复杂查询没有有效索引时或索引效率低下时）
>
>- 可以减少冗余记录的查询。


<br><br>

---

## 适应优化器优化

……


<br><br>

---