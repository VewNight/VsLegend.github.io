# 线程基础

## 线程的一些概念

### 同步与异步：
- 同步和异步关注的是消息通信机制 。

- 同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。
 
- 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。

### 阻塞与非阻塞：
- 在处理 IO 的时候，阻塞和非阻塞都是同步 IO。

- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。

- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。


### 阻塞同步与非阻塞同步，阻塞异步与非阻塞异步
- 阻塞同步悲观的认为，每次操作都会有其他线程同时操作，因此需要排队进行数据操作，那么等待中的线程就会进入阻塞状态，这就是阻塞同步。

- 非阻塞同步基于冲突检测的乐观并发策略，他会先操作数据，如果没有线程征用共享数据，则操作成功，否则就产生了冲突，他将会重试直到成功为止（如CAS）。
	

### 进程和线程：
- 进程：在计算机中，我们把一个任务称为一个进程

- 线程：某些进程内部还需要同时执行多个子任务，同时支持进程内的多个子任务同时执行，这些子任务就是线程。同一进程下的线程共享数据。

### 进程和线程的关系：
- 一个进程可以包含一个或多个线程，但至少会有一个线程。

- 操作系统调度的最小任务单位其实不是进程，而是线程。

- 常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

多线程模型是Java程序最基本的并发模型。


## Java中的线程

### 线程的生命周期：
1. 新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序调用 start()方法启动这个线程。

2. 就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

3. 运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

4. 阻塞状态:如果一个线程执行了sleep、wait等方法失去所占用资源之后或当前CPU时间片消耗完毕重新等待资源调用器调用时，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。
    > 如下：
	> - 等待阻塞（Waiting）：运行状态中的线程执行 wait()、join()等方法，使线程进入到等待阻塞状态，改状态只能通过其他线程调用notify()或notifyAll()方法唤醒从而进入就绪状态。
                                                                                                               >
	> - 同步阻塞（Blocked）：线程在获取 锁失败时(因为同步锁被其他线程占用)，当前线程进入阻塞状态。待其他线程释放锁后，线程会进入就绪状态继续同其他线程竞争锁。或者是IO操作时的IO阻塞状态。
                                                                                                               >
	> - 定时阻塞（Timed waiting）：通过调用线程的 sleep(time) 或 join(timeout) ，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，线程重新转入就绪状态。

5. 死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

![图例](/img/thread_model.png)
