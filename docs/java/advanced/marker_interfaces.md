# 接口标记(Marker Interfaces  |  tagging interface)

## 说明
标识接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。
使用标记接口的唯一目的是使得可以用 instanceof 进行类型查询。

一些容器例如 Ejb 容器，servlet 容器或运行时环境依赖标记接口识别类是否需要进行某种处理，比如 serialialbe 接口标记类需要进行序列化操作。

- java.io.Serializable：未实现此接口的类将无法使其任何状态序列化或反序列化。为保证 serialVersionUID 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 serialVersionUID 值。
- java.lang.Cloneable：表明 Object.clone() 方法可以合法地对该类实例进行按字段复制.实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的）。如果在没有实现 Cloneable 接口的实例上调用 Object 的 clone 方法，则会导致抛出 CloneNotSupportedException 异常。
- java.util.RandomAccess：用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。
- java.rmi.Remote：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”（扩展 java.rmi.Remote 的接口）中指定的这些方法才可远程使用。


## 接口默认方法与接口静态方法
1. 接口默认方法：只需在方法名前面加个 default 关键字即可实现默认方法。如果一个接口要添加一个方法，那所有的接口实现类都要去实现，而某些实现类根本就不需要实现这个方法也要写一个空实现，所以接口默认方法就是为了解决实现类不需要实现的方法而写的空实现。

1. 接口静态方法：在接口方法前加 static 关键字即可实现接口静态方法，类似于默认方法，但是我们不能在实现类中覆盖它们，可以避免默认方法在实现类中被覆盖实现。

1. 两者异同点：
> - 接口默认方法、静态方法都可以有多个。
> - 默认方法通过实例调用，静态方法通过接口名调用。
> - 接口默认方法用default修饰，接口静态方法用static修饰。default默认方法关键字只能用在接口中。
> - 默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。
> - 静态方法不能被继承及覆盖，所以只被具体所在的接口调用。
